# 동네마켓 백엔드 기술명세서

**버전:** 1.0
**작성일:** 2026년 1월
**대상:** 백엔드 개발자, 시스템 아키텍트
**기반 문서:** PRD v1.0, SRS v1.0, ERD v1.0

---

## 목차

1. [기술 스택 개요](#1-기술-스택-개요)
2. [시스템 아키텍처](#2-시스템-아키텍처)
3. [실시간 통신](#3-실시간-통신)
4. [위치 기반 서비스](#4-위치-기반-서비스)
5. [데이터베이스 설계](#5-데이터베이스-설계)
6. [메시지 큐](#6-메시지-큐)
7. [배치 처리](#7-배치-처리)
8. [외부 API 연동](#8-외부-api-연동)
9. [보안](#9-보안)
10. [인프라 및 배포](#10-인프라-및-배포)
11. [성능 요구사항](#11-성능-요구사항)
12. [기술 채택 이유](#12-기술-채택-이유)

---

## 1. 기술 스택 개요

### 1.1 Core Framework

| 기술 | 버전 | 용도 |
|------|------|------|
| Java | 21 LTS | 메인 언어 |
| Spring Boot | 3.2.x | 애플리케이션 프레임워크 |
| Spring WebFlux | 3.2.x | 리액티브 웹 처리 (위치 스트리밍) |
| Spring Data JPA | 3.2.x | ORM |
| Spring Security | 6.2.x | 인증/인가 |

### 1.2 데이터 저장소

| 기술 | 버전 | 용도 |
|------|------|------|
| PostgreSQL | 16.x | 메인 RDBMS |
| PostGIS | 3.4.x | 공간 데이터 확장 |
| Redis | 7.2.x | 캐싱, 실시간 위치, Pub/Sub |
| Elasticsearch | 8.x | 상품 검색 엔진 |

### 1.3 메시징 및 비동기 처리

| 기술 | 버전 | 용도 |
|------|------|------|
| Apache Kafka | 3.6.x | 이벤트 스트리밍, 주문 파이프라인 |
| Spring Batch | 5.1.x | 정산, 구독 처리 배치 |

### 1.4 의존성 목록 (build.gradle)

```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.2'
    id 'io.spring.dependency-management' version '1.1.4'
}

java {
    sourceCompatibility = '21'
}

dependencies {
    // Spring Boot Core
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
    implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-websocket'

    // Spring Batch
    implementation 'org.springframework.boot:spring-boot-starter-batch'

    // Kafka
    implementation 'org.springframework.kafka:spring-kafka'

    // Database
    runtimeOnly 'org.postgresql:postgresql'
    implementation 'org.hibernate.orm:hibernate-spatial:6.4.1.Final'
    implementation 'org.locationtech.jts:jts-core:1.19.0'

    // Redis
    implementation 'org.redisson:redisson-spring-boot-starter:3.25.0'

    // JWT
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'

    // Utilities
    implementation 'org.mapstruct:mapstruct:1.5.5.Final'
    annotationProcessor 'org.mapstruct:mapstruct-processor:1.5.5.Final'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // Monitoring
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'io.micrometer:micrometer-registry-prometheus'

    // API Documentation
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'

    // Test
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.testcontainers:postgresql'
    testImplementation 'org.testcontainers:kafka'
}
```

---

## 2. 시스템 아키텍처

### 2.1 전체 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            Client Layer                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ Customer App │  │  Store App   │  │  Rider App   │  │  Admin Web   │ │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘ │
└─────────┼─────────────────┼─────────────────┼─────────────────┼─────────┘
          │                 │                 │                 │
          ▼                 ▼                 ▼                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          API Gateway (Spring Cloud Gateway)              │
│                    - 라우팅, 인증, Rate Limiting, 로드밸런싱              │
└─────────────────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          Service Layer                                   │
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │Auth Service │  │User Service │  │Store Service│  │Order Service│    │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │  Delivery   │  │Subscription │  │  Payment    │  │Notification │    │
│  │  Service    │  │  Service    │  │  Service    │  │  Service    │    │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐                                       │
│  │Search Svc   │  │Settlement   │                                       │
│  │(ES 연동)    │  │  Service    │                                       │
│  └─────────────┘  └─────────────┘                                       │
└─────────────────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          Data Layer                                      │
│                                                                          │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐         │
│  │   PostgreSQL    │  │     Redis       │  │  Elasticsearch  │         │
│  │   + PostGIS     │  │  (Cache/GEO/    │  │   (상품 검색)   │         │
│  │   (메인 DB)     │  │   Pub/Sub)      │  │                 │         │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘         │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     Apache Kafka (이벤트 스트리밍)               │   │
│  │   order.created | delivery.requested | notification.send        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 패키지 구조

```
com.dongnaemarket/
├── DongnaeMarketApplication.java
├── config/                          # 설정 클래스
│   ├── RedisConfig.java
│   ├── KafkaConfig.java
│   ├── SecurityConfig.java
│   ├── WebSocketConfig.java
│   └── ElasticsearchConfig.java
├── domain/                          # 도메인 모델
│   ├── user/
│   │   ├── entity/
│   │   ├── repository/
│   │   ├── service/
│   │   └── dto/
│   ├── store/
│   ├── order/
│   ├── delivery/
│   ├── subscription/
│   └── payment/
├── api/                             # REST API
│   └── v1/
│       ├── UserController.java
│       ├── StoreController.java
│       ├── OrderController.java
│       └── DeliveryController.java
├── websocket/                       # WebSocket 핸들러
│   ├── DeliveryLocationHandler.java
│   └── NotificationHandler.java
├── event/                           # 이벤트 처리
│   ├── publisher/
│   └── listener/
├── batch/                           # 배치 작업
│   ├── SubscriptionOrderJob.java
│   └── SettlementJob.java
├── external/                        # 외부 API 클라이언트
│   ├── payment/
│   ├── map/
│   └── notification/
└── common/                          # 공통 유틸리티
    ├── exception/
    ├── response/
    └── util/
```

---

## 3. 실시간 통신

### 3.1 WebSocket 채널 설계

| 기능 | 채널 패턴 | 갱신 주기 | 설명 |
|------|----------|----------|------|
| 배달원 위치 스트리밍 | `/topic/delivery/{orderId}/location` | 3-5초 | 배달 중 위치 실시간 전송 |
| 주문 상태 업데이트 | `/topic/order/{orderId}/status` | 이벤트 발생 시 | 주문 상태 변경 알림 |
| 마트 신규 주문 알림 | `/topic/store/{storeId}/orders` | 이벤트 발생 시 | 새 주문 접수 알림 |
| 배달원 배달 요청 | `/topic/rider/{riderId}/requests` | 이벤트 발생 시 | 배달 요청 푸시 |
| 관리자 대시보드 | `/topic/admin/live-map` | 5초 | 전체 배달 현황 |

### 3.2 WebSocket 설정

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Redis를 외부 브로커로 사용 (서버 간 메시지 공유)
        config.enableStompBrokerRelay("/topic", "/queue")
              .setRelayHost("${REDIS_HOST}")
              .setRelayPort(61613);
        config.setApplicationDestinationPrefixes("/app");
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS()
                .setHeartbeatTime(25000);
    }
}
```

### 3.3 배달원 위치 스트리밍 핸들러

```java
@Controller
@RequiredArgsConstructor
@Slf4j
public class DeliveryLocationController {

    private final SimpMessagingTemplate messagingTemplate;
    private final RedisTemplate<String, Object> redisTemplate;
    private final GeofencingService geofencingService;

    /**
     * 배달원 위치 수신 및 브로드캐스트
     * - 3-5초 주기로 배달원 앱에서 전송
     * - Redis GEO에 저장 후 구독자에게 전파
     */
    @MessageMapping("/delivery/{orderId}/location")
    public void updateLocation(
            @DestinationVariable String orderId,
            @Payload RiderLocationDto location) {

        // 1. Redis에 현재 위치 저장 (TTL 60초)
        String key = "rider:location:" + location.getRiderId();
        redisTemplate.opsForValue().set(key, location, Duration.ofSeconds(60));

        // 2. Redis GEO에 위치 업데이트
        redisTemplate.opsForGeo().add(
            "geo:riders:active",
            new Point(location.getLongitude(), location.getLatitude()),
            location.getRiderId().toString()
        );

        // 3. Geofencing 체크 (500m, 100m 근접 알림)
        geofencingService.checkAndNotifyProximity(
            Long.valueOf(orderId),
            location.getRiderId(),
            location.getLatitude(),
            location.getLongitude()
        );

        // 4. 해당 주문을 구독 중인 고객에게 브로드캐스트
        messagingTemplate.convertAndSend(
            "/topic/delivery/" + orderId + "/location",
            location
        );

        log.debug("Location updated - orderId: {}, riderId: {}, lat: {}, lng: {}",
            orderId, location.getRiderId(), location.getLatitude(), location.getLongitude());
    }
}
```

### 3.4 Redis Pub/Sub 설정

```java
@Configuration
public class RedisPubSubConfig {

    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(
            RedisConnectionFactory connectionFactory,
            MessageListenerAdapter orderStatusListener,
            MessageListenerAdapter newOrderListener) {

        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);

        // 동적 채널 구독 (패턴 매칭)
        container.addMessageListener(orderStatusListener,
            new PatternTopic("dongnae:order:*:status"));
        container.addMessageListener(newOrderListener,
            new PatternTopic("dongnae:store:*:new-order"));

        return container;
    }
}
```

### 3.5 Pub/Sub 채널 구조

```
dongnae:order:{orderId}:status      # 주문 상태 변경
dongnae:store:{storeId}:new-order   # 신규 주문 알림
dongnae:rider:{riderId}:request     # 배달 요청
dongnae:delivery:{deliveryId}:eta   # ETA 업데이트
dongnae:notification:{userId}       # 개인 알림
```

### 3.6 이벤트 발행 서비스

```java
@Service
@RequiredArgsConstructor
public class RealtimeEventPublisher {

    private final StringRedisTemplate redisTemplate;
    private final ObjectMapper objectMapper;

    public void publishOrderStatusChange(Long orderId, OrderStatus newStatus) {
        String channel = "dongnae:order:" + orderId + ":status";
        OrderStatusEvent event = new OrderStatusEvent(orderId, newStatus, LocalDateTime.now());
        redisTemplate.convertAndSend(channel, toJson(event));
    }

    public void publishNewOrderToStore(Long storeId, OrderSummaryDto order) {
        String channel = "dongnae:store:" + storeId + ":new-order";
        redisTemplate.convertAndSend(channel, toJson(order));
    }

    public void publishDeliveryRequest(Long riderId, DeliveryRequestDto request) {
        String channel = "dongnae:rider:" + riderId + ":request";
        redisTemplate.convertAndSend(channel, toJson(request));
    }

    private String toJson(Object obj) {
        try {
            return objectMapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("JSON 직렬화 실패", e);
        }
    }
}
```

---

## 4. 위치 기반 서비스

### 4.1 기술 스택 요약

| 기능 | 기술 | 명령/함수 | 설명 |
|------|------|----------|------|
| 배달원 위치 저장 | Redis GEO | `GEOADD` | 실시간 위치 (TTL 60초) |
| 주변 배달원 검색 | Redis GEO | `GEORADIUS` / `GEOSEARCH` | 반경 내 가용 배달원 조회 |
| 마트-고객 거리 | Redis GEO | `GEODIST` | 배달 거리 및 요금 산정 |
| 근접 알림 | Geofencing | Custom | 500m/100m 도착 임박 알림 |
| 주변 마트 검색 | PostGIS | `ST_DWithin` | 배달 가능 마트 목록 |
| 배달 구역 확인 | PostGIS | `ST_Contains` | 배달원 담당 구역 확인 |

### 4.2 Redis GEO 서비스 구현

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class LocationService {

    private final StringRedisTemplate redisTemplate;
    private static final String RIDERS_GEO_KEY = "geo:riders:active";
    private static final String STORES_GEO_KEY = "geo:stores";

    /**
     * 배달원 현재 위치 업데이트
     * - 배달 중 3-5초 주기로 호출
     */
    public void updateRiderLocation(Long riderId, double lat, double lng) {
        redisTemplate.opsForGeo().add(
            RIDERS_GEO_KEY,
            new Point(lng, lat),  // Redis GEO는 경도, 위도 순서
            riderId.toString()
        );

        // 배달 완료 후 자동 제거를 위한 별도 TTL 키
        redisTemplate.opsForValue().set(
            "rider:active:" + riderId,
            "1",
            Duration.ofMinutes(5)
        );
    }

    /**
     * 마트 주변 가용 배달원 검색
     * @param radiusKm 검색 반경 (km)
     * @return 거리순 정렬된 배달원 목록
     */
    public List<RiderDistanceDto> findNearbyAvailableRiders(
            double storeLat, double storeLng, double radiusKm) {

        GeoResults<RedisGeoCommands.GeoLocation<String>> results =
            redisTemplate.opsForGeo().radius(
                RIDERS_GEO_KEY,
                new Circle(
                    new Point(storeLng, storeLat),
                    new Distance(radiusKm, Metrics.KILOMETERS)
                ),
                RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()
                    .includeDistance()
                    .includeCoordinates()
                    .sortAscending()
                    .limit(10)
            );

        if (results == null) {
            return Collections.emptyList();
        }

        return results.getContent().stream()
            .map(result -> RiderDistanceDto.builder()
                .riderId(Long.parseLong(result.getContent().getName()))
                .distanceKm(result.getDistance().getValue())
                .latitude(result.getContent().getPoint().getY())
                .longitude(result.getContent().getPoint().getX())
                .build())
            .toList();
    }

    /**
     * 두 지점 간 거리 계산 (배달 요금 산정용)
     */
    public Double calculateDistanceKm(double lat1, double lng1, double lat2, double lng2) {
        // Haversine 공식 사용
        final int R = 6371; // 지구 반경 (km)

        double latDistance = Math.toRadians(lat2 - lat1);
        double lngDistance = Math.toRadians(lng2 - lng1);

        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                * Math.sin(lngDistance / 2) * Math.sin(lngDistance / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }
}
```

### 4.3 Geofencing 서비스 (근접 알림)

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class GeofencingService {

    private final LocationService locationService;
    private final NotificationService notificationService;
    private final DeliveryRepository deliveryRepository;

    // 상태 캐싱 (중복 알림 방지)
    private final Map<Long, ProximityStatus> lastProximityStatus = new ConcurrentHashMap<>();

    public enum ProximityStatus {
        EN_ROUTE,      // 이동 중 (500m 이상)
        APPROACHING,   // 접근 중 (500m 이내)
        ARRIVED,       // 도착 임박 (100m 이내)
        UNKNOWN
    }

    /**
     * 근접 알림 체크 (배달원 위치 업데이트 시 호출)
     * - 500m 접근: "배달원이 곧 도착합니다"
     * - 100m 접근: "배달원이 도착했습니다. 문 앞에서 맞이해주세요"
     */
    @Async
    public void checkAndNotifyProximity(Long orderId, Long riderId,
                                        double riderLat, double riderLng) {

        Delivery delivery = deliveryRepository.findByOrderId(orderId).orElse(null);
        if (delivery == null || delivery.getStatus() != DeliveryStatus.DELIVERING) {
            return;
        }

        // 고객 배송지 좌표
        double customerLat = delivery.getDeliveryLatitude().doubleValue();
        double customerLng = delivery.getDeliveryLongitude().doubleValue();

        // 거리 계산
        double distanceKm = locationService.calculateDistanceKm(
            riderLat, riderLng, customerLat, customerLng
        );

        // 현재 상태 판정
        ProximityStatus currentStatus;
        if (distanceKm <= 0.1) {
            currentStatus = ProximityStatus.ARRIVED;
        } else if (distanceKm <= 0.5) {
            currentStatus = ProximityStatus.APPROACHING;
        } else {
            currentStatus = ProximityStatus.EN_ROUTE;
        }

        // 상태 변경 시에만 알림 발송 (중복 방지)
        ProximityStatus lastStatus = lastProximityStatus.get(orderId);
        if (lastStatus != currentStatus) {
            lastProximityStatus.put(orderId, currentStatus);

            Long customerId = delivery.getOrder().getUserId();

            switch (currentStatus) {
                case APPROACHING -> {
                    notificationService.sendPush(
                        customerId,
                        "배달원 접근 알림",
                        "배달원이 500m 이내로 접근했습니다!",
                        Map.of("orderId", orderId.toString(), "type", "PROXIMITY")
                    );
                    log.info("500m 근접 알림 발송 - orderId: {}", orderId);
                }
                case ARRIVED -> {
                    notificationService.sendPush(
                        customerId,
                        "배달 도착 임박",
                        "배달원이 곧 도착합니다. 문 앞에서 맞이해주세요!",
                        Map.of("orderId", orderId.toString(), "type", "ARRIVED")
                    );
                    log.info("100m 도착 알림 발송 - orderId: {}", orderId);
                }
            }
        }
    }

    /**
     * 배달 완료 시 상태 정리
     */
    public void clearProximityStatus(Long orderId) {
        lastProximityStatus.remove(orderId);
    }
}
```

### 4.4 PostGIS 공간 쿼리 (주변 마트 검색)

```java
@Repository
public interface StoreRepository extends JpaRepository<Store, Long> {

    /**
     * 고객 위치 기준 배달 가능한 주변 마트 조회
     * - ST_DWithin: 마트의 배달 반경 내 고객이 있는지 확인
     * - ST_Distance: 거리순 정렬
     */
    @Query(value = """
        SELECT s.store_id, s.store_name, s.category, s.average_rating,
               s.delivery_fee, s.min_order_amount, s.is_open,
               ST_Distance(
                   s.location::geography,
                   ST_SetSRID(ST_MakePoint(:lng, :lat), 4326)::geography
               ) as distance_meters
        FROM stores s
        WHERE s.status = 'APPROVED'
          AND s.is_open = true
          AND ST_DWithin(
                s.location::geography,
                ST_SetSRID(ST_MakePoint(:lng, :lat), 4326)::geography,
                s.delivery_radius_km * 1000
              )
        ORDER BY distance_meters ASC
        LIMIT :limit
        """, nativeQuery = true)
    List<StoreDistanceProjection> findNearbyStores(
        @Param("lat") double latitude,
        @Param("lng") double longitude,
        @Param("limit") int limit
    );

    /**
     * 특정 위치가 마트 배달 가능 구역 내인지 확인
     */
    @Query(value = """
        SELECT CASE WHEN ST_DWithin(
                 s.location::geography,
                 ST_SetSRID(ST_MakePoint(:lng, :lat), 4326)::geography,
                 s.delivery_radius_km * 1000
               ) THEN true ELSE false END
        FROM stores s
        WHERE s.store_id = :storeId
        """, nativeQuery = true)
    boolean isWithinDeliveryArea(
        @Param("storeId") Long storeId,
        @Param("lat") double latitude,
        @Param("lng") double longitude
    );
}
```

### 4.5 ETA 계산 서비스

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ETACalculationService {

    private final LocationService locationService;
    private final KakaoMobilityClient mapApiClient;

    // 평균 속도 (km/h)
    private static final double SPEED_WALK = 5.0;
    private static final double SPEED_BICYCLE = 15.0;
    private static final double SPEED_MOTORCYCLE = 30.0;

    /**
     * ETA 계산
     * 1차: 외부 지도 API (Kakao Mobility) - 실시간 교통 반영
     * 2차: 직선 거리 기반 폴백 계산
     */
    public ETAResult calculateETA(Long riderId, VehicleType vehicleType,
                                  double riderLat, double riderLng,
                                  double destLat, double destLng) {

        // 외부 API 시도
        try {
            RouteResponse route = mapApiClient.getRoute(
                riderLat, riderLng, destLat, destLng, vehicleType
            );

            return ETAResult.builder()
                .estimatedMinutes(route.getDurationMinutes())
                .distanceKm(route.getDistanceKm())
                .confidence(ConfidenceLevel.HIGH)
                .calculatedAt(LocalDateTime.now())
                .build();

        } catch (Exception e) {
            log.warn("외부 API ETA 계산 실패, 폴백 사용: {}", e.getMessage());
        }

        // 폴백: 직선 거리 기반 계산
        double distance = locationService.calculateDistanceKm(
            riderLat, riderLng, destLat, destLng
        );

        double speed = switch (vehicleType) {
            case WALK -> SPEED_WALK;
            case BICYCLE -> SPEED_BICYCLE;
            case MOTORCYCLE -> SPEED_MOTORCYCLE;
        };

        // 1.3배 여유 (실제 경로 ≈ 직선 거리 * 1.3)
        int estimatedMinutes = (int) Math.ceil((distance / speed) * 60 * 1.3);

        return ETAResult.builder()
            .estimatedMinutes(estimatedMinutes)
            .distanceKm(distance)
            .confidence(ConfidenceLevel.LOW)
            .calculatedAt(LocalDateTime.now())
            .build();
    }
}
```

---

## 5. 데이터베이스 설계

### 5.1 PostgreSQL 스키마 (핵심 테이블)

```sql
-- PostGIS 확장 활성화
CREATE EXTENSION IF NOT EXISTS postgis;

-- ============================================
-- 사용자 모듈
-- ============================================
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    name VARCHAR(50) NOT NULL,
    phone VARCHAR(20) NOT NULL UNIQUE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('CUSTOMER', 'STORE_OWNER', 'RIDER', 'ADMIN')),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE TABLE addresses (
    address_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    label VARCHAR(20) NOT NULL,
    address_line1 VARCHAR(200) NOT NULL,
    address_line2 VARCHAR(100),
    latitude DECIMAL(10, 8) NOT NULL,
    longitude DECIMAL(11, 8) NOT NULL,
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- 마트 모듈
-- ============================================
CREATE TABLE stores (
    store_id BIGSERIAL PRIMARY KEY,
    owner_id BIGINT NOT NULL REFERENCES users(user_id),
    store_name VARCHAR(100) NOT NULL,
    business_number VARCHAR(20) NOT NULL UNIQUE,
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    delivery_radius_km DECIMAL(3,1) NOT NULL DEFAULT 2.0,
    min_order_amount INT NOT NULL DEFAULT 0,
    delivery_fee INT NOT NULL DEFAULT 3000,
    average_rating DECIMAL(2,1) NOT NULL DEFAULT 0.0,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    is_open BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 공간 인덱스
CREATE INDEX idx_stores_location ON stores USING GIST(location);

CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    store_id BIGINT NOT NULL REFERENCES stores(store_id),
    category_id BIGINT REFERENCES categories(category_id),
    product_name VARCHAR(100) NOT NULL,
    description TEXT,
    price INT NOT NULL,
    sale_price INT,
    stock INT NOT NULL DEFAULT 0,
    image_url VARCHAR(500),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- 주문 모듈
-- ============================================
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(20) NOT NULL UNIQUE,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    store_id BIGINT NOT NULL REFERENCES stores(store_id),
    order_type VARCHAR(20) NOT NULL DEFAULT 'REGULAR',
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    total_product_price INT NOT NULL,
    delivery_fee INT NOT NULL,
    used_point INT NOT NULL DEFAULT 0,
    final_price INT NOT NULL,
    delivery_address VARCHAR(300) NOT NULL,
    delivery_latitude DECIMAL(10, 8) NOT NULL,
    delivery_longitude DECIMAL(11, 8) NOT NULL,
    delivery_request TEXT,
    ordered_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    accepted_at TIMESTAMP,
    completed_at TIMESTAMP
);

CREATE TABLE order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    product_id BIGINT NOT NULL REFERENCES products(product_id),
    product_name_snapshot VARCHAR(100) NOT NULL,
    price_snapshot INT NOT NULL,
    quantity INT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- 배달 모듈
-- ============================================
CREATE TABLE riders (
    rider_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL UNIQUE REFERENCES users(user_id),
    vehicle_type VARCHAR(20) NOT NULL,
    license_plate VARCHAR(20),
    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    delivery_area GEOGRAPHY(POLYGON, 4326),
    status VARCHAR(20) NOT NULL DEFAULT 'OFFLINE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE deliveries (
    delivery_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL UNIQUE REFERENCES orders(order_id),
    rider_id BIGINT REFERENCES riders(rider_id),
    status VARCHAR(20) NOT NULL DEFAULT 'REQUESTED',
    pickup_at TIMESTAMP,
    delivered_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE rider_locations (
    location_id BIGSERIAL PRIMARY KEY,
    rider_id BIGINT NOT NULL REFERENCES riders(rider_id),
    delivery_id BIGINT REFERENCES deliveries(delivery_id),
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    accuracy DECIMAL(5,2),
    speed DECIMAL(5,2),
    heading DECIMAL(5,2),
    recorded_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 시간 기반 인덱스 (90일 보관 정책)
CREATE INDEX idx_rider_locations_recorded ON rider_locations(recorded_at);
CREATE INDEX idx_rider_locations_rider ON rider_locations(rider_id, recorded_at DESC);

-- ============================================
-- 구독 모듈
-- ============================================
CREATE TABLE subscriptions (
    subscription_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    store_id BIGINT NOT NULL REFERENCES stores(store_id),
    subscription_name VARCHAR(100) NOT NULL,
    cycle_type VARCHAR(20) NOT NULL,
    delivery_day VARCHAR(20) NOT NULL,
    next_delivery_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### 5.2 Redis 데이터 구조

| 키 패턴 | 타입 | TTL | 용도 |
|--------|------|-----|------|
| `rider:location:{riderId}` | String (JSON) | 60s | 배달원 최신 위치 |
| `geo:riders:active` | GEO | - | 활성 배달원 위치 (GEO 인덱스) |
| `geo:stores` | GEO | - | 마트 위치 (GEO 인덱스) |
| `session:{sessionId}` | Hash | 30min | 사용자 세션 |
| `token:refresh:{userId}` | String | 7d | 리프레시 토큰 |
| `token:blacklist:{jti}` | String | 1h | 블랙리스트 토큰 |
| `cache:store:{storeId}` | String (JSON) | 5min | 마트 정보 캐시 |
| `cache:product:{productId}` | String (JSON) | 5min | 상품 정보 캐시 |
| `stock:{productId}` | String | - | 재고 수량 (분산 락) |
| `rate-limit:{userId}:{endpoint}` | String | 1min | API Rate Limiting |

### 5.3 Redis 설정

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedissonClient redissonClient(
            @Value("${spring.redis.host}") String host,
            @Value("${spring.redis.port}") int port) {

        Config config = new Config();
        config.useSingleServer()
              .setAddress("redis://" + host + ":" + port)
              .setConnectionPoolSize(64)
              .setConnectionMinimumIdleSize(24)
              .setDatabase(0);
        return Redisson.create(config);
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate(
            RedisConnectionFactory connectionFactory) {

        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}
```

### 5.4 Elasticsearch 인덱스 설계

```json
PUT /products
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "analysis": {
      "analyzer": {
        "korean_analyzer": {
          "type": "custom",
          "tokenizer": "nori_tokenizer",
          "filter": ["nori_readingform", "lowercase", "nori_part_of_speech"]
        },
        "autocomplete_analyzer": {
          "type": "custom",
          "tokenizer": "edge_ngram_tokenizer",
          "filter": ["lowercase"]
        }
      },
      "tokenizer": {
        "edge_ngram_tokenizer": {
          "type": "edge_ngram",
          "min_gram": 1,
          "max_gram": 20,
          "token_chars": ["letter", "digit"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "productId": { "type": "long" },
      "storeId": { "type": "long" },
      "storeName": { "type": "keyword" },
      "productName": {
        "type": "text",
        "analyzer": "korean_analyzer",
        "fields": {
          "autocomplete": {
            "type": "text",
            "analyzer": "autocomplete_analyzer",
            "search_analyzer": "standard"
          },
          "keyword": { "type": "keyword" }
        }
      },
      "description": { "type": "text", "analyzer": "korean_analyzer" },
      "categoryPath": { "type": "keyword" },
      "price": { "type": "integer" },
      "salePrice": { "type": "integer" },
      "stock": { "type": "integer" },
      "isAvailable": { "type": "boolean" },
      "storeLocation": { "type": "geo_point" },
      "createdAt": { "type": "date" }
    }
  }
}
```

---

## 6. 메시지 큐

### 6.1 Kafka 토픽 설계

| 토픽명 | 파티션 | 복제 | 용도 |
|--------|--------|------|------|
| `order.created` | 6 | 3 | 신규 주문 생성 이벤트 |
| `order.status.changed` | 6 | 3 | 주문 상태 변경 이벤트 |
| `payment.completed` | 3 | 3 | 결제 완료 이벤트 |
| `payment.failed` | 3 | 3 | 결제 실패 이벤트 |
| `delivery.requested` | 6 | 3 | 배달 요청 이벤트 |
| `delivery.status.changed` | 6 | 3 | 배달 상태 변경 |
| `notification.send` | 6 | 3 | 알림 발송 요청 |
| `subscription.order` | 3 | 3 | 구독 자동 주문 생성 |
| `settlement.process` | 3 | 3 | 정산 처리 요청 |

### 6.2 이벤트 메시지 스키마

```java
@Data
@Builder
public class OrderCreatedEvent {
    private String eventId;
    private Long orderId;
    private String orderNumber;
    private Long userId;
    private Long storeId;
    private OrderType orderType;
    private Integer totalAmount;
    private LocalDateTime createdAt;
}

@Data
@Builder
public class OrderStatusChangedEvent {
    private String eventId;
    private Long orderId;
    private OrderStatus previousStatus;
    private OrderStatus newStatus;
    private String changedBy;  // USER, STORE, RIDER, SYSTEM
    private LocalDateTime changedAt;
}

@Data
@Builder
public class DeliveryRequestedEvent {
    private String eventId;
    private Long deliveryId;
    private Long orderId;
    private Long storeId;
    private LocationDto storeLocation;
    private LocationDto customerLocation;
    private Integer deliveryFee;
    private LocalDateTime requestedAt;
}
```

### 6.3 Kafka 설정

```java
@Configuration
@EnableKafka
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> config = new HashMap<>();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        config.put(ProducerConfig.ACKS_CONFIG, "all");
        config.put(ProducerConfig.RETRIES_CONFIG, 3);
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);
        return new DefaultKafkaProducerFactory<>(config);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory(
            ConsumerFactory<String, Object> consumerFactory) {

        ConcurrentKafkaListenerContainerFactory<String, Object> factory =
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);
        factory.setConcurrency(3);
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE);
        return factory;
    }
}
```

### 6.4 이벤트 발행자/소비자

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class OrderEventPublisher {

    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Transactional
    public void publishOrderCreated(Order order) {
        OrderCreatedEvent event = OrderCreatedEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .orderId(order.getOrderId())
            .orderNumber(order.getOrderNumber())
            .userId(order.getUserId())
            .storeId(order.getStoreId())
            .totalAmount(order.getFinalPrice())
            .createdAt(LocalDateTime.now())
            .build();

        kafkaTemplate.send("order.created", order.getOrderId().toString(), event)
            .whenComplete((result, ex) -> {
                if (ex != null) {
                    log.error("주문 생성 이벤트 발행 실패: {}", event.getEventId(), ex);
                } else {
                    log.info("주문 생성 이벤트 발행: {}", event.getEventId());
                }
            });
    }
}

@Service
@RequiredArgsConstructor
@Slf4j
public class OrderEventConsumer {

    private final StoreNotificationService storeNotificationService;
    private final RealtimeEventPublisher realtimePublisher;

    @KafkaListener(topics = "order.created", groupId = "order-notification-group")
    public void handleOrderCreated(OrderCreatedEvent event, Acknowledgment ack) {
        try {
            log.info("주문 생성 이벤트 처리: {}", event.getEventId());

            // 마트에 신규 주문 알림
            storeNotificationService.notifyNewOrder(event.getStoreId(), event);

            // 실시간 WebSocket 푸시
            realtimePublisher.publishNewOrderToStore(event.getStoreId(), event);

            ack.acknowledge();

        } catch (Exception e) {
            log.error("주문 생성 이벤트 처리 실패: {}", event.getEventId(), e);
            throw e;
        }
    }
}
```

---

## 7. 배치 처리

### 7.1 배치 작업 목록

| 작업명 | 스케줄 | 설명 |
|--------|--------|------|
| `SubscriptionOrderJob` | 매일 00:00 | 구독 자동 주문 생성 |
| `StoreSettlementJob` | 매주 월요일 01:00 | 마트 주간 정산 |
| `RiderSettlementJob` | 매일 01:00 | 배달원 일일 정산 |
| `LocationHistoryCleanupJob` | 매일 03:00 | 90일 초과 위치 이력 삭제 |
| `ExpiredPointCleanupJob` | 매일 04:00 | 만료 포인트 처리 |
| `ProductIndexSyncJob` | 매시간 | Elasticsearch 색인 동기화 |

### 7.2 구독 자동 주문 배치

```java
@Configuration
@EnableBatchProcessing
@RequiredArgsConstructor
public class SubscriptionOrderJobConfig {

    private final JobRepository jobRepository;
    private final PlatformTransactionManager transactionManager;

    @Bean
    public Job subscriptionOrderJob(Step subscriptionOrderStep) {
        return new JobBuilder("subscriptionOrderJob", jobRepository)
            .start(subscriptionOrderStep)
            .listener(new JobCompletionListener())
            .build();
    }

    @Bean
    public Step subscriptionOrderStep(
            ItemReader<Subscription> subscriptionReader,
            ItemProcessor<Subscription, Order> subscriptionProcessor,
            ItemWriter<Order> orderWriter) {

        return new StepBuilder("subscriptionOrderStep", jobRepository)
            .<Subscription, Order>chunk(100, transactionManager)
            .reader(subscriptionReader)
            .processor(subscriptionProcessor)
            .writer(orderWriter)
            .faultTolerant()
            .retryLimit(3)
            .retry(PaymentFailedException.class)
            .skipLimit(10)
            .skip(InsufficientStockException.class)
            .build();
    }
}

@Component
@RequiredArgsConstructor
public class SubscriptionOrderProcessor implements ItemProcessor<Subscription, Order> {

    private final SubscriptionItemRepository subscriptionItemRepository;
    private final StockService stockService;

    @Override
    public Order process(Subscription subscription) throws Exception {
        // 구독 상품 조회
        List<SubscriptionItem> items = subscriptionItemRepository
            .findBySubscriptionId(subscription.getSubscriptionId());

        // 품절 상품 필터링
        List<OrderItem> availableItems = items.stream()
            .filter(item -> stockService.isAvailable(item.getProductId(), item.getQuantity()))
            .map(this::toOrderItem)
            .toList();

        if (availableItems.isEmpty()) {
            return null; // 건너뛰기
        }

        return Order.builder()
            .userId(subscription.getUserId())
            .storeId(subscription.getStoreId())
            .orderType(OrderType.SUBSCRIPTION)
            .items(availableItems)
            .status(OrderStatus.PENDING)
            .build();
    }
}
```

### 7.3 스케줄러 설정

```java
@Configuration
@EnableScheduling
@RequiredArgsConstructor
public class BatchSchedulerConfig {

    private final JobLauncher jobLauncher;
    private final Job subscriptionOrderJob;
    private final Job storeSettlementJob;
    private final Job locationCleanupJob;

    // 매일 00:00 - 구독 자동 주문
    @Scheduled(cron = "0 0 0 * * *")
    public void runSubscriptionOrderJob() throws Exception {
        JobParameters params = new JobParametersBuilder()
            .addLocalDate("targetDate", LocalDate.now().plusDays(1))
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();
        jobLauncher.run(subscriptionOrderJob, params);
    }

    // 매주 월요일 01:00 - 마트 정산
    @Scheduled(cron = "0 0 1 * * MON")
    public void runStoreSettlementJob() throws Exception {
        LocalDate endDate = LocalDate.now().minusDays(1);
        LocalDate startDate = endDate.minusDays(6);

        JobParameters params = new JobParametersBuilder()
            .addLocalDate("startDate", startDate)
            .addLocalDate("endDate", endDate)
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();
        jobLauncher.run(storeSettlementJob, params);
    }

    // 매일 03:00 - 위치 이력 정리 (90일 초과)
    @Scheduled(cron = "0 0 3 * * *")
    public void runLocationCleanupJob() throws Exception {
        JobParameters params = new JobParametersBuilder()
            .addLocalDate("cutoffDate", LocalDate.now().minusDays(90))
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();
        jobLauncher.run(locationCleanupJob, params);
    }
}
```

---

## 8. 외부 API 연동

### 8.1 결제 연동 (Toss Payments)

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class TossPaymentsClient {

    private final RestClient restClient;

    @Value("${payment.toss.secret-key}")
    private String secretKey;

    @Value("${payment.toss.api-url}")
    private String apiUrl;

    /**
     * 결제 승인
     */
    public PaymentApprovalResponse approvePayment(PaymentApprovalRequest request) {
        try {
            return restClient.post()
                .uri(apiUrl + "/v1/payments/confirm")
                .header("Authorization", "Basic " + encodeSecretKey())
                .contentType(MediaType.APPLICATION_JSON)
                .body(Map.of(
                    "paymentKey", request.getPaymentKey(),
                    "orderId", request.getOrderId(),
                    "amount", request.getAmount()
                ))
                .retrieve()
                .body(PaymentApprovalResponse.class);

        } catch (RestClientException e) {
            log.error("결제 승인 실패: {}", e.getMessage());
            throw new PaymentProcessingException("결제 승인에 실패했습니다.", e);
        }
    }

    /**
     * 결제 취소
     */
    public PaymentCancelResponse cancelPayment(String paymentKey, String cancelReason) {
        return restClient.post()
            .uri(apiUrl + "/v1/payments/" + paymentKey + "/cancel")
            .header("Authorization", "Basic " + encodeSecretKey())
            .contentType(MediaType.APPLICATION_JSON)
            .body(Map.of("cancelReason", cancelReason))
            .retrieve()
            .body(PaymentCancelResponse.class);
    }

    /**
     * 빌링키 발급 (구독 결제용)
     */
    public BillingKeyResponse issueBillingKey(BillingKeyRequest request) {
        return restClient.post()
            .uri(apiUrl + "/v1/billing/authorizations/issue")
            .header("Authorization", "Basic " + encodeSecretKey())
            .contentType(MediaType.APPLICATION_JSON)
            .body(request)
            .retrieve()
            .body(BillingKeyResponse.class);
    }

    private String encodeSecretKey() {
        return Base64.getEncoder().encodeToString((secretKey + ":").getBytes());
    }
}
```

### 8.2 지도 API 연동 (Kakao Mobility)

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class KakaoMobilityClient {

    private final RestClient restClient;

    @Value("${kakao.api-key}")
    private String apiKey;

    /**
     * 경로 탐색 (ETA 계산용)
     */
    public RouteResponse getRoute(double originLat, double originLng,
                                  double destLat, double destLng,
                                  VehicleType vehicleType) {

        String uri = UriComponentsBuilder
            .fromHttpUrl("https://apis-navi.kakaomobility.com/v1/directions")
            .queryParam("origin", originLng + "," + originLat)
            .queryParam("destination", destLng + "," + destLat)
            .queryParam("priority", "RECOMMEND")
            .build()
            .toUriString();

        KakaoRouteResponse response = restClient.get()
            .uri(uri)
            .header("Authorization", "KakaoAK " + apiKey)
            .retrieve()
            .body(KakaoRouteResponse.class);

        return RouteResponse.builder()
            .durationMinutes(response.getRoutes().get(0).getSummary().getDuration() / 60)
            .distanceKm(response.getRoutes().get(0).getSummary().getDistance() / 1000.0)
            .build();
    }
}
```

### 8.3 FCM 푸시 알림

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class FCMNotificationService {

    private final FirebaseMessaging firebaseMessaging;
    private final UserDeviceRepository deviceRepository;

    /**
     * 단일 사용자 푸시 알림
     */
    public void sendPush(Long userId, String title, String body, Map<String, String> data) {
        List<UserDevice> devices = deviceRepository.findActiveDevicesByUserId(userId);

        for (UserDevice device : devices) {
            Message message = Message.builder()
                .setToken(device.getFcmToken())
                .setNotification(Notification.builder()
                    .setTitle(title)
                    .setBody(body)
                    .build())
                .putAllData(data)
                .setAndroidConfig(AndroidConfig.builder()
                    .setPriority(AndroidConfig.Priority.HIGH)
                    .setNotification(AndroidNotification.builder()
                        .setSound("default")
                        .setChannelId("delivery_updates")
                        .build())
                    .build())
                .setApnsConfig(ApnsConfig.builder()
                    .setAps(Aps.builder()
                        .setSound("default")
                        .build())
                    .build())
                .build();

            try {
                firebaseMessaging.send(message);
            } catch (FirebaseMessagingException e) {
                log.error("FCM 발송 실패 - userId: {}, error: {}", userId, e.getMessage());
            }
        }
    }
}
```

### 8.4 소셜 로그인 (Kakao OAuth2)

```java
@Configuration
@EnableWebSecurity
public class OAuth2Config {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -> oauth2
                .authorizationEndpoint(auth -> auth
                    .baseUri("/oauth2/authorize")
                )
                .redirectionEndpoint(redirect -> redirect
                    .baseUri("/oauth2/callback/*")
                )
                .userInfoEndpoint(userInfo -> userInfo
                    .userService(customOAuth2UserService())
                )
                .successHandler(oAuth2SuccessHandler())
            );
        return http.build();
    }
}
```

---

## 9. 보안

### 9.1 JWT 인증

```java
@Service
@RequiredArgsConstructor
public class JwtTokenProvider {

    @Value("${jwt.access-token-validity}")
    private long accessTokenValidity;  // 1시간

    @Value("${jwt.refresh-token-validity}")
    private long refreshTokenValidity;  // 7일

    private final RSAPrivateKey privateKey;
    private final RSAPublicKey publicKey;
    private final StringRedisTemplate redisTemplate;

    public TokenResponse createTokens(User user) {
        String jti = UUID.randomUUID().toString();
        Date now = new Date();

        // Access Token
        String accessToken = Jwts.builder()
            .header().type("JWT").and()
            .subject(user.getUserId().toString())
            .claim("role", user.getRole().name())
            .id(jti)
            .issuedAt(now)
            .expiration(new Date(now.getTime() + accessTokenValidity))
            .signWith(privateKey, Jwts.SIG.RS256)
            .compact();

        // Refresh Token
        String refreshToken = Jwts.builder()
            .subject(user.getUserId().toString())
            .id(UUID.randomUUID().toString())
            .issuedAt(now)
            .expiration(new Date(now.getTime() + refreshTokenValidity))
            .signWith(privateKey, Jwts.SIG.RS256)
            .compact();

        // Redis에 Refresh Token 저장
        redisTemplate.opsForValue().set(
            "token:refresh:" + user.getUserId(),
            refreshToken,
            Duration.ofMillis(refreshTokenValidity)
        );

        return new TokenResponse(accessToken, refreshToken);
    }

    public Claims validateToken(String token) {
        Claims claims = Jwts.parser()
            .verifyWith(publicKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();

        // 블랙리스트 확인
        String jti = claims.getId();
        if (Boolean.TRUE.equals(redisTemplate.hasKey("token:blacklist:" + jti))) {
            throw new InvalidTokenException("Token has been revoked");
        }

        return claims;
    }

    public void revokeToken(String token) {
        Claims claims = validateToken(token);
        String jti = claims.getId();
        long ttl = claims.getExpiration().getTime() - System.currentTimeMillis();

        if (ttl > 0) {
            redisTemplate.opsForValue().set(
                "token:blacklist:" + jti,
                "revoked",
                Duration.ofMillis(ttl)
            );
        }
    }
}
```

### 9.2 API Rate Limiting

```java
@Aspect
@Component
@RequiredArgsConstructor
public class RateLimitingAspect {

    private final StringRedisTemplate redisTemplate;

    @Around("@annotation(rateLimit)")
    public Object checkRateLimit(ProceedingJoinPoint joinPoint, RateLimit rateLimit)
            throws Throwable {

        String userId = SecurityContextHolder.getContext().getAuthentication().getName();
        String endpoint = joinPoint.getSignature().toShortString();
        String key = "rate-limit:" + userId + ":" + endpoint;

        Long currentCount = redisTemplate.opsForValue().increment(key);

        if (currentCount == 1) {
            redisTemplate.expire(key, Duration.ofSeconds(rateLimit.period()));
        }

        if (currentCount > rateLimit.limit()) {
            throw new RateLimitExceededException("요청 한도를 초과했습니다.");
        }

        return joinPoint.proceed();
    }
}

// 사용 예시
@PostMapping("/orders")
@RateLimit(limit = 10, period = 60)  // 분당 10회
public ResponseEntity<OrderResponse> createOrder(@RequestBody CreateOrderRequest request) {
    // ...
}
```

### 9.3 Security 설정

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                // Public endpoints
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/stores/nearby").permitAll()
                .requestMatchers("/api/v1/products/search").permitAll()
                .requestMatchers("/ws/**").permitAll()

                // Role-based access
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/v1/stores/manage/**").hasRole("STORE_OWNER")
                .requestMatchers("/api/v1/riders/**").hasRole("RIDER")

                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

---

## 10. 인프라 및 배포

### 10.1 Docker 설정

```dockerfile
# Dockerfile
FROM eclipse-temurin:21-jdk-alpine AS builder
WORKDIR /app
COPY gradlew build.gradle settings.gradle ./
COPY gradle gradle
COPY src src
RUN chmod +x ./gradlew && ./gradlew bootJar --no-daemon

FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
RUN addgroup -g 1000 appgroup && adduser -u 1000 -G appgroup -D appuser
USER appuser
COPY --from=builder /app/build/libs/*.jar app.jar

ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"
EXPOSE 8080
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 10.2 Docker Compose (개발 환경)

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=local
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/dongnae_market
      - SPRING_REDIS_HOST=redis
      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092
    depends_on:
      - postgres
      - redis
      - kafka

  postgres:
    image: postgis/postgis:16-3.4-alpine
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=dongnae_market
      - POSTGRES_USER=dongnae
      - POSTGRES_PASSWORD=dongnae123
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7.2-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes

  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    depends_on:
      - zookeeper

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    ports:
      - "9200:9200"
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false

volumes:
  postgres_data:
```

### 10.3 Kubernetes 배포

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dongnae-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dongnae-api
  template:
    spec:
      containers:
        - name: dongnae-api
          image: dongnae-market/api:latest
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 60
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 30
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: dongnae-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: dongnae-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

---

## 11. 성능 요구사항

### 11.1 성능 목표

| 지표 | 목표값 | 측정 방법 |
|------|--------|----------|
| API 응답 시간 (P95) | < 200ms | Prometheus + Grafana |
| API 응답 시간 (P99) | < 500ms | Prometheus + Grafana |
| WebSocket 지연 | < 1초 | Custom metrics |
| 동시 접속자 | 10,000+ | Load testing |
| 처리량 (TPS) | 1,000+ | Gatling/JMeter |
| 가용성 | 99.9% | Uptime monitoring |

### 11.2 모니터링 설정

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
      probes:
        enabled: true
  metrics:
    tags:
      application: dongnae-market
    distribution:
      percentiles-histogram:
        http.server.requests: true
```

### 11.3 Custom Metrics

```java
@Component
@RequiredArgsConstructor
public class DeliveryMetrics {

    private final MeterRegistry meterRegistry;
    private Counter deliveryRequestCounter;
    private Timer deliveryEtaTimer;

    @PostConstruct
    public void init() {
        deliveryRequestCounter = Counter.builder("delivery.requests.total")
            .description("Total delivery requests")
            .register(meterRegistry);

        deliveryEtaTimer = Timer.builder("delivery.eta.calculation")
            .description("ETA calculation time")
            .publishPercentiles(0.5, 0.95, 0.99)
            .register(meterRegistry);
    }
}
```

---

## 부록

### A. 에러 코드 체계

| 코드 범위 | 도메인 |
|----------|--------|
| 1xxx | 인증/인가 |
| 2xxx | 사용자 |
| 3xxx | 마트/상품 |
| 4xxx | 주문 |
| 5xxx | 배달 |
| 6xxx | 결제 |
| 7xxx | 구독 |
| 9xxx | 시스템 |

### B. API 버저닝

```
/api/v1/...  # 현재 버전
/api/v2/...  # 차기 버전
```

### C. 환경 변수

```yaml
# application-prod.yml
spring:
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
  redis:
    host: ${REDIS_HOST}
    password: ${REDIS_PASSWORD}
  kafka:
    bootstrap-servers: ${KAFKA_SERVERS}

jwt:
  access-token-validity: 3600000    # 1시간
  refresh-token-validity: 604800000 # 7일

payment:
  toss:
    secret-key: ${TOSS_SECRET_KEY}
    api-url: https://api.tosspayments.com

kakao:
  api-key: ${KAKAO_API_KEY}
```

---

## 12. 기술 채택 이유

### 12.1 기술 선정 총괄표

| 기술 | 사용 위치 | 채택 이유 | 대안 기술 |
|------|----------|----------|----------|
| WebSocket (STOMP) | 배달 추적, 실시간 알림 | 양방향 통신, 낮은 지연 | HTTP Polling, SSE |
| Redis GEO | 배달원 위치 검색 | O(N+log(M)) 고속 공간 쿼리 | PostGIS 단독 |
| Redis Pub/Sub | 서버 간 이벤트 공유 | 스케일아웃 시 세션 브로드캐스트 | Kafka (과도) |
| PostGIS | 배달 구역 검색 | 복잡한 공간 쿼리 (Polygon) | MongoDB GeoJSON |
| Kafka | 주문/배달 파이프라인 | 순서 보장, 이벤트 재처리 | RabbitMQ |
| Elasticsearch | 상품 검색 | 한글 형태소 분석, 자동완성 | PostgreSQL FTS |
| Spring Batch | 구독/정산 배치 | 청크 처리, 재시작/스킵 | Quartz 단독 |
| JWT RS256 | 인증 | 무상태 서버, 비대칭 키 | Session 기반 |
| PostgreSQL | 메인 DB | ACID, PostGIS 확장 | MySQL |
| Docker/K8s | 배포/운영 | 환경 일관성, 오토스케일링 | VM 기반 |

---

### 12.2 실시간 통신 기술

#### WebSocket (STOMP 프로토콜)
| 항목 | 내용 |
|------|------|
| **사용 위치** | 배달원 위치 스트리밍 (3-5초), 주문 상태 알림, 마트 신규 주문 알림 |
| **채택 이유** | HTTP Polling 대비 **지연 시간 90% 감소** (수 초 → 수십 ms), 서버 부하 감소 (연결 유지로 핸드셰이크 오버헤드 제거), 양방향 통신으로 서버 푸시 가능 |
| **대안 비교** | SSE(Server-Sent Events)는 단방향만 지원하여 배달원 → 서버 위치 전송에 부적합 |
| **기대 효과** | 실시간 배달 추적 UX 향상, 고객 만족도 증가 |

#### Redis Pub/Sub
| 항목 | 내용 |
|------|------|
| **사용 위치** | 다중 서버 환경에서 WebSocket 메시지 브로드캐스트, 주문 상태 변경 이벤트 전파 |
| **채택 이유** | **서버 스케일아웃 시 필수** - 고객이 서버 A에 연결, 배달원이 서버 B에 연결된 경우 Redis를 통해 메시지 중계, 설정 간단 (Spring WebSocket + Redis adapter) |
| **대안 비교** | Kafka Pub/Sub은 영속성 불필요한 실시간 메시지에 과도함, RabbitMQ는 추가 인프라 필요 |
| **기대 효과** | 무중단 서버 확장 가능, 단일 장애점 제거 |

---

### 12.3 위치 기반 서비스 기술

#### Redis GEO
| 항목 | 내용 |
|------|------|
| **사용 위치** | 실시간 배달원 위치 저장/조회, 주변 가용 배달원 검색 (반경 3km 내) |
| **채택 이유** | **메모리 기반 O(N+log(M)) 복잡도**로 밀리초 단위 응답, GEORADIUS 명령으로 반경 검색 + 거리순 정렬 한 번에 처리, TTL 지원으로 비활성 배달원 자동 제거 |
| **대안 비교** | PostGIS는 디스크 I/O 발생하여 실시간 위치에 부적합 (수십 ms vs 수 ms) |
| **기대 효과** | 배달원 매칭 응답 시간 < 100ms 달성 |

#### PostGIS (PostgreSQL 확장)
| 항목 | 내용 |
|------|------|
| **사용 위치** | 마트 배달 가능 구역 검색, 배달원 담당 구역 Polygon 저장, 거리 기반 배달비 산정 |
| **채택 이유** | **복잡한 공간 연산 지원** (ST_DWithin, ST_Contains, ST_Distance), PostgreSQL과 트랜잭션 공유로 데이터 정합성 보장, GiST 인덱스로 대용량 공간 쿼리 최적화 |
| **대안 비교** | MongoDB GeoJSON은 트랜잭션 지원 미흡, 관계형 조인 불가 |
| **기대 효과** | "주변 마트 검색" 쿼리 < 50ms, 정확한 배달 가능 여부 판단 |

#### Geofencing (Custom 구현)
| 항목 | 내용 |
|------|------|
| **사용 위치** | 배달원 500m/100m 접근 시 고객 알림 |
| **채택 이유** | 외부 서비스(Google Geofencing API) 대비 **비용 절감**, Redis GEO + Haversine 공식으로 충분한 정확도 (±20m), 알림 발송 로직과 긴밀한 통합 가능 |
| **기대 효과** | 고객이 배달 도착 전 준비 가능, 부재 시 재배달 감소 |

---

### 12.4 메시징 및 비동기 처리 기술

#### Apache Kafka
| 항목 | 내용 |
|------|------|
| **사용 위치** | 주문 생성 → 결제 → 마트 알림 → 배달 요청 파이프라인, 알림 발송 큐, 정산 처리 |
| **채택 이유** | **순서 보장** (파티션 내 FIFO) - 주문 상태 변경 순서 중요, **이벤트 재처리** 가능 (Consumer offset reset), **고가용성** (복제 팩터 3), **높은 처리량** (수십만 TPS) |
| **대안 비교** | RabbitMQ는 메시지 영속성/재처리에 약함, 처리량 한계 |
| **기대 효과** | 피크 시간 주문 급증 시에도 안정적 처리, 장애 발생 시 이벤트 유실 없음 |

#### Spring Batch
| 항목 | 내용 |
|------|------|
| **사용 위치** | 구독 자동 주문 생성 (매일 00:00), 마트/배달원 정산 (주간/일간), 90일 초과 위치 이력 삭제 |
| **채택 이유** | **청크 기반 처리**로 메모리 효율적 (100건씩 처리), **재시작/스킵 정책** - 결제 실패 시 3회 재시도 후 스킵, **트랜잭션 관리** - 청크 단위 롤백으로 부분 실패 허용 |
| **대안 비교** | Quartz 단독 사용 시 대용량 처리 로직 직접 구현 필요 |
| **기대 효과** | 수만 건 구독 주문도 안정적 처리, 실패 건 추적 용이 |

---

### 12.5 검색 기술

#### Elasticsearch
| 항목 | 내용 |
|------|------|
| **사용 위치** | 상품 검색 (키워드, 카테고리, 가격 필터), 자동완성, 마트 내 상품 검색 |
| **채택 이유** | **한글 형태소 분석** (nori 플러그인) - "삼겹살" 검색 시 "삼겹", "살" 분리 인식, **Edge N-gram 자동완성** - "사과" 입력 시 "사", "사과", "사과주스" 연관 검색, **복합 필터링** - 카테고리 + 가격 범위 + 재고 상태 동시 적용 |
| **대안 비교** | PostgreSQL Full-Text Search는 한글 형태소 분석 미지원, 자동완성 구현 복잡 |
| **기대 효과** | 검색 정확도 향상, 검색 응답 < 100ms |

---

### 12.6 데이터베이스 기술

#### PostgreSQL
| 항목 | 내용 |
|------|------|
| **사용 위치** | 모든 비즈니스 데이터 (사용자, 마트, 상품, 주문, 배달, 구독, 정산) |
| **채택 이유** | **ACID 트랜잭션** - 주문/결제 데이터 정합성 필수, **PostGIS 확장** - 공간 데이터 네이티브 지원, **JSON 타입** - 유연한 메타데이터 저장, **성숙한 에코시스템** - 모니터링, 백업, 복제 도구 풍부 |
| **대안 비교** | MySQL은 PostGIS 미지원, 공간 쿼리 성능 열위 |
| **기대 효과** | 데이터 무결성 보장, 복잡한 조인 쿼리 최적화 |

#### Redis
| 항목 | 내용 |
|------|------|
| **사용 위치** | 세션/토큰 캐시, 실시간 위치, API Rate Limiting, 재고 분산 락, Pub/Sub |
| **채택 이유** | **인메모리 고속 처리** (< 1ms 응답), **다양한 자료구조** (String, Hash, Set, Sorted Set, GEO), **TTL 지원** - 세션/토큰 자동 만료, **Pub/Sub 내장** - 추가 MQ 없이 실시간 메시지 |
| **대안 비교** | Memcached는 자료구조 제한, Pub/Sub 미지원 |
| **기대 효과** | DB 부하 감소, API 응답 시간 단축 |

---

### 12.7 인증/보안 기술

#### JWT RS256
| 항목 | 내용 |
|------|------|
| **사용 위치** | 사용자 인증, API 요청 인가, 마이크로서비스 간 토큰 전파 |
| **채택 이유** | **무상태 서버** - 세션 저장소 불필요로 수평 확장 용이, **RS256 비대칭 키** - Private Key는 Auth 서버만 보유, Public Key로 모든 서비스가 검증 가능, **토큰 내 클레임** - role, userId 포함으로 DB 조회 감소 |
| **대안 비교** | Session 기반은 서버 간 세션 공유 필요 (Redis Session 등), 확장성 제한 |
| **기대 효과** | 인증 서버 병목 제거, 보안 강화 |

#### Rate Limiting (Redis 기반)
| 항목 | 내용 |
|------|------|
| **사용 위치** | 주문 생성 API (분당 10회), 로그인 시도 (분당 5회), 검색 API (분당 60회) |
| **채택 이유** | **분산 환경 지원** - Redis INCR + EXPIRE로 서버 간 카운트 공유, **슬라이딩 윈도우** 구현 가능, **낮은 오버헤드** - Redis 연산 O(1) |
| **기대 효과** | DDoS/Brute Force 방어, 서비스 안정성 확보 |

---

### 12.8 인프라 기술

#### Docker + Kubernetes
| 항목 | 내용 |
|------|------|
| **사용 위치** | 모든 서비스 컨테이너화, 프로덕션 오케스트레이션 |
| **채택 이유** | **환경 일관성** - 개발/스테이징/프로덕션 동일 이미지, **오토스케일링** (HPA) - CPU 70% 초과 시 자동 Pod 증가, **무중단 배포** (Rolling Update), **Self-healing** - Pod 장애 시 자동 재시작 |
| **대안 비교** | VM 기반은 리소스 낭비, 배포 시간 길어짐 |
| **기대 효과** | 배포 시간 단축 (분 단위), 인프라 비용 최적화 |

#### Prometheus + Grafana
| 항목 | 내용 |
|------|------|
| **사용 위치** | API 응답 시간, 에러율, JVM 메트릭, 비즈니스 메트릭 (주문 수, 배달 시간) |
| **채택 이유** | **Pull 기반 수집** - 서비스 변경 없이 모니터링 추가, **PromQL** - 유연한 쿼리 및 알림 조건 설정, **Grafana 시각화** - 대시보드 커스터마이징 |
| **기대 효과** | 장애 조기 감지, SLA 준수 모니터링 |

---

### 12.3 기술 선정 의사결정 플로우

```
                        ┌─────────────────────────────┐
                        │     요구사항 분석            │
                        │  - 실시간 배달 추적          │
                        │  - 10,000+ 동시 접속        │
                        │  - API 응답 < 200ms         │
                        └─────────────┬───────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              │                       │                       │
              ▼                       ▼                       ▼
    ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
    │  실시간 통신     │     │  위치 기반 서비스 │     │  데이터 처리     │
    │                 │     │                 │     │                 │
    │ HTTP Polling?   │     │ DB만으로 가능?   │     │ 동기 처리?      │
    │ → 지연 문제     │     │ → 성능 부족     │     │ → 병목 발생     │
    │                 │     │                 │     │                 │
    │ ✓ WebSocket    │     │ ✓ Redis GEO    │     │ ✓ Kafka        │
    │ ✓ Redis Pub/Sub│     │ ✓ PostGIS      │     │ ✓ Spring Batch │
    └─────────────────┘     └─────────────────┘     └─────────────────┘
```

---

*문서 끝*
